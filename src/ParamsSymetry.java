
import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import static java.awt.event.KeyEvent.VK_ESCAPE;
import java.awt.event.KeyListener;
import static java.lang.Thread.sleep;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.util.Random;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.border.Border;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Fred
 */
public class ParamsSymetry extends javax.swing.JPanel {

    /**
     * Creates new form ParamsSaccade
     */
    JLabel icone ;
        
    public ParamsSymetry(JLabel icone) {
        initComponents();
        this.icone = icone ;
        if (OrthoVS.user.nom != null) {
            jGridSize.setEnabled (true) ;
            jDurée.setEnabled (true) ;
            //jDurée.setValue (1) ;
            jGridSize.setSelectedIndex(2);
            //jLabelGrid.setEnabled (true) ;
            //jGridSize.setSelectedIndex(1);
        }
        else {
            jGridSize.setSelectedIndex(1);
            jGridSize.setEnabled (false) ;
            //jLabelGrid.setEnabled (false) ;
            jGridSize.setSelectedIndex(1);
            jDurée.setEnabled (false) ;
            jDurée.setValue (1) ;
        }
        addComponentListener ( new ComponentAdapter () {
            public void componentShown ( ComponentEvent e )
            {
                icone.setVisible(true);
            }

            public void componentHidden ( ComponentEvent e )
            {
                icone.setVisible(false);
            }
        } );    
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTitle = new javax.swing.JLabel();
        jDurée = new javax.swing.JSpinner();
        jSeparator2 = new javax.swing.JSeparator();
        jManualStart = new javax.swing.JButton();
        jAutoStar = new javax.swing.JButton();
        jSeparator3 = new javax.swing.JSeparator();
        jLabel7 = new javax.swing.JLabel();
        jTrophy = new javax.swing.JSpinner();
        jGridSize = new javax.swing.JComboBox<>();
        jLabel12 = new javax.swing.JLabel();
        jLabelGrid = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jSeparator4 = new javax.swing.JSeparator();
        jLabel8 = new javax.swing.JLabel();

        setBackground(new java.awt.Color(255, 255, 255));
        setOpaque(false);
        setPreferredSize(new java.awt.Dimension(431, 513));

        jTitle.setFont(new java.awt.Font("Tahoma", 1, 36)); // NOI18N
        jTitle.setForeground(new java.awt.Color(102, 102, 102));
        jTitle.setText("Symétrie du papillon :");

        jDurée.setModel(new javax.swing.SpinnerNumberModel(1, 1, 15, 1));
        jDurée.setToolTipText("Durée de la série (en mn)");
        jDurée.setOpaque(false);
        jDurée.setPreferredSize(new java.awt.Dimension(35, 20));
        jDurée.setValue(1);

        jManualStart.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jManualStart.setText("Démarrer");
        jManualStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jManualStartActionPerformed(evt);
            }
        });

        jAutoStar.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jAutoStar.setText("Progression auto");
        jAutoStar.setEnabled(false);
        jAutoStar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jAutoStarActionPerformed(evt);
            }
        });

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel7.setText("Un trophé pour ");

        jTrophy.setModel(new javax.swing.SpinnerNumberModel(5, 2, 5, 1));
        jTrophy.setOpaque(false);

        jGridSize.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "3 x 2", "3 x 3", "4 x 2", "4 x 3", "4 x 4", "5 x 2", "5 x 3", "5 x 4", "5 x 5" }));
        jGridSize.setToolTipText("Taille de la grille");

        jLabel12.setText("(1 à 15 minutes)");
        jLabel12.setEnabled(false);

        jLabelGrid.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabelGrid.setText("Taille Grille :");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel5.setText("Durée de la série :");

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel8.setText("grilles");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(38, 38, 38)
                .addComponent(jManualStart)
                .addGap(26, 26, 26)
                .addComponent(jAutoStar)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addComponent(jTitle)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator2)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(29, 29, 29)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel7)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jTrophy, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jLabel8))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabelGrid)
                                            .addComponent(jLabel5))
                                        .addGap(47, 47, 47)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(jDurée, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jGridSize, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(jLabel12)))
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator3)
                            .addComponent(jSeparator4))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTitle)
                .addGap(36, 36, 36)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jGridSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelGrid))
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jDurée, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel12))
                .addGap(24, 24, 24)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel7)
                    .addComponent(jTrophy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8))
                .addGap(21, 21, 21)
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jManualStart)
                    .addComponent(jAutoStar))
                .addContainerGap(196, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jManualStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jManualStartActionPerformed
        int size = (Integer) jGridSize.getSelectedIndex() ;
        int nbGrilles   = (Integer) jTrophy.getValue() ;
        int durée =  (Integer) jDurée.getValue() ;
        //on lance l'activité
        OrthoVS.fen.enableMenuBar(false);
        //OrthoVS.fen.setExtendedState(OrthoVS.fen.getExtendedState() | JFrame.MAXIMIZED_BOTH);
        //OrthoVS.fen.repaint () ;
        
        LaunchSymetry l = new LaunchSymetry (this, size, durée, nbGrilles) ;
    }//GEN-LAST:event_jManualStartActionPerformed

    private void jAutoStarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAutoStarActionPerformed
        /*int n = (Integer) spinNbCycles.getValue();
        int sp   = Integer.parseInt((String) jSpeed.getSelectedItem());
        //on lance l'activité
        LaunchFixation test = new LaunchFixation ( n, sp, jManuel.isSelected(), true ) ;
        test.start () ;*/
    }//GEN-LAST:event_jAutoStarActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jAutoStar;
    public static javax.swing.JSpinner jDurée;
    private javax.swing.JComboBox<String> jGridSize;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel5;
    public static javax.swing.JLabel jLabel7;
    public static javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabelGrid;
    private javax.swing.JButton jManualStart;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    public static javax.swing.JLabel jTitle;
    public static javax.swing.JSpinner jTrophy;
    // End of variables declaration//GEN-END:variables
}

class LaunchSymetry extends Thread {
    
    Thread t ;    
    JPanel p ;
    int size, durée ;
    static int nbGrillesForTrophy ;
    JButton jButterfly ;
    
    static boolean notFin = true ;
    
    //Paramètres
    Random rand = new Random () ;
    static GrilleSymetry originalGrid ;
    static GrilleSymetry mirrorGrid ;
    static boolean symetrieVerticale ;
    
    //Trphés
    static JLabel trophy[] ;
    static int trophyNumber = 0 ;
    static int threeCount = 0 ;
    static SoundClips snd ;
    
    //Progression de jeu
    static public boolean newGame = false ;
    //Butterfly
    final ScheduledThreadPoolExecutor executor ;
    
    LaunchSymetry (JPanel p, int size, int durée, int nbGrilles) {
        this.p = p ;
        this.size = size ;
        this.durée = durée * 60 ;
        this.nbGrillesForTrophy = nbGrilles ;
        //On cache les menus
        //OrthoVS.fen.enableMenuBar(false);
        OrthoVS.fen.setExtendedState(OrthoVS.fen.getExtendedState() | JFrame.MAXIMIZED_BOTH);
        OrthoVS.fen.jPatient.setVisible (false) ;
        OrthoVS.fen.symetryParam.setVisible(false);
        OrthoVS.fen.validate () ;
        //OrthoVS.fen.chartPanelOK.setVisible(false);
        
        
        

        //Icon butterfly
        jButterfly = new JButton ( UserInfo.iconButterfly ) ;
        jButterfly.setBorderPainted(false);
        jButterfly.setContentAreaFilled(false);
        OrthoVS.fen.getContentPane ().add (jButterfly) ;
        jButterfly.setBounds(OrthoVS.fen.getContentPane().getWidth()-260 , 10 , 256, 256);
        jButterfly.setVisible(true);
        executor = new ScheduledThreadPoolExecutor(1);
        
        //On lance le thread
        t = new Thread (this, "launchSymetry") ;
        t.start ( ) ;
    }
    
    @Override
    public void run () {
        
        long tempsDebut = System.currentTimeMillis();
        //Taille des grilles
        int h, v ;
        switch (size) {
            case 0 : h=3; v=2; break;
            case 1 : h=3; v=3; break;
            case 2 : h=4; v=2; break;
            case 3 : h=4; v=3; break;
            case 4 : h=4; v=4; break;
            case 5 : h=5; v=2; break;
            case 6 : h=5; v=3; break;
            case 7 : h=5; v=4; break;
            case 8 : h=5; v=5; break;
            default: h=4; v=3; break;
        }
        //Horizontal ou vertical ?
        if (size < 8)
            symetrieVerticale = rand.nextBoolean() ;
        else
            symetrieVerticale = false ;
        originalGrid = new GrilleSymetry (v, h, symetrieVerticale, false) ;
        mirrorGrid   = new GrilleSymetry (v, h, symetrieVerticale, true) ;
        //On ajoute les grilles au JFrame
        OrthoVS.fen.getContentPane().add (originalGrid) ;
        OrthoVS.fen.getContentPane().add (mirrorGrid) ;
        originalGrid.validate () ;
        mirrorGrid.validate () ;
        //On écoute le clavier pour la touche ESC
        originalGrid.addKeyListener(originalGrid);
        
        //Create trophy
        trophy = new JLabel[5] ;
        for (int i=0; i<5; i++) {
            trophy[i] = new JLabel() ;
            trophy[i].setIcon(new ImageIcon(MainFenetre.tinyTrophy));
            if (symetrieVerticale)
                trophy[i].setBounds(originalGrid.getX() + (i * 85) + (originalGrid.getWidth()-4*85-64)/2, originalGrid.getY() - 100 , 64, 64);
            else
                trophy[i].setBounds(originalGrid.getX() + (i * 85) + (2*originalGrid.getWidth()-4*85-64)/2, originalGrid.getY() - 100 , 64, 64);
            OrthoVS.fen.getContentPane().add(trophy[i]) ;
            trophy[i].setEnabled(false);
        }
        trophyNumber = 0 ;
        
        //On redessine
        OrthoVS.fen.repaint () ;
        originalGrid.requestFocusInWindow();
        
        
        //On initialise les grilles
        originalGrid.randomInit();
        mirrorGrid.randomInit();
        
        //Le papillon bouge
        // voir https://stackoverflow.com/questions/1519091/scheduledexecutorservice-with-variable-delay
        //pour avoir un rate variable
        executor.scheduleAtFixedRate(() -> moveButterfly(),1000, 150, TimeUnit.MILLISECONDS);
        notFin = true ;  
        do {
            newGame = false ;
            //On laisse un peu passer le temps...
            try { sleep ( 250 ) ;} catch (Exception e) {}
            //Si ESC on sort
            if (originalGrid.out) notFin = false ;
            //On reprend le focus pour la touche ESC
            originalGrid.requestFocusInWindow();
            
            //On change la grille
            if (newGame) {
                originalGrid.randomInit();
                mirrorGrid.randomInit();
            }
            //C'est la fin ?
            float seconds = (System.currentTimeMillis() - tempsDebut) / 1000F;
            //progressBar.setValue((int) seconds);
            if (seconds > durée) notFin = false ;
        } while (notFin) ;
       
        //On arrête les threads en cours
        //if (timerThrd.isAlive()) timerThrd.interrupt();
        executor.shutdownNow() ;
        //On nettoie l'affichage
        OrthoVS.fen.getContentPane().remove(originalGrid);
        OrthoVS.fen.getContentPane().remove(mirrorGrid);
        OrthoVS.fen.repaint () ;
        snd = new SoundClips (3) ; //applauses
        snd.start () ;
        try { sleep ( 3000 ) ;} catch (Exception e) {}
        OrthoVS.fen.getContentPane().remove(jButterfly);
        for (int i=0; i<trophy.length; i++)
            OrthoVS.fen.getContentPane().remove(trophy[i]) ;
        OrthoVS.fen.enableMenuBar(true);
        OrthoVS.fen.jPatient.setVisible (true) ;
        p.setVisible (true) ;
        OrthoVS.fen.setExtendedState(JFrame.NORMAL);
        OrthoVS.fen.repaint () ;
    }
    
    private void moveButterfly () {
        int w = originalGrid.getWidth() ;
        jButterfly.setLocation(jButterfly.getX()-2, jButterfly.getY()+1);
        if (!symetrieVerticale) w = w * 2;
        if (jButterfly.getX() < (originalGrid.getX()+w-20)) {
            originalGrid.out = true ;
            jButterfly.setVisible(false);
            //notFin = false;
        }
            
    }
    
    static public boolean checkForSymetry () {
        int h = LaunchSymetry.originalGrid.grid.length ;
        int v = LaunchSymetry.originalGrid.grid[0].length ;
        
        boolean isOK = true ;
        int ii, jj ;
        for (int i=0; i<h; i++)
            for (int j=0; j<v; j++) {
                if (symetrieVerticale) {
                    ii = i ; jj = v-j-1 ;
                }
                else {
                    ii = h-i-1 ; jj = j ;
                }
                    
                if (originalGrid.grid[i][j].getBackground() != mirrorGrid.grid[ii][jj].getBackground() )
                    isOK = false ;
                //mirrorGrid.grid[ii][jj].setBackground(originalGrid.grid[i][j].getBackground() ) ; isOK = false ;
            }
        if (isOK) threeCount++ ;
        if (threeCount == nbGrillesForTrophy & trophyNumber<5) {
            trophy[trophyNumber++].setEnabled(true);
            threeCount = 0 ;
            snd = new SoundClips (4) ; //bad
            snd.start () ;
        }
        return isOK ;
    }
}

class GrilleSymetry extends JPanel implements ActionListener, KeyListener {
    
    //paramètres
    private boolean vertical ;
    private boolean isMirror ;
    private int h, v ;
    Random rand = new Random () ;
    //Pour sortir
    static public boolean out = false ;
    //Cases
    public MonkeyButton[][] grid ;
    
    //Constructor
    GrilleSymetry (int i, int j, boolean vertical, boolean mirror) {
        //Paramètres
        this.out = false ;
        this.vertical = vertical ;
        this.isMirror = mirror ;
        this.h = i;
        this.v = j ;
        //Taille du panel
        if (vertical) {
            int t = i ;
            i = j ;
            j = t ;
        }
        //On positionne la grille
        if (vertical) {
            if (mirror)
                setBounds((OrthoVS.fen.getContentPane().getWidth()-(i*100))/2, (OrthoVS.fen.getContentPane().getHeight()/2), i*100, j*100);
            else
                setBounds((OrthoVS.fen.getContentPane().getWidth()-(i*100))/2, (OrthoVS.fen.getContentPane().getHeight()/2-(j*100)), i*100, j*100);
        } else {
            if (mirror)
                setBounds((OrthoVS.fen.getContentPane().getWidth()/2), (OrthoVS.fen.getContentPane().getHeight()-(j*100))/2, i*100, j*100);
            else
                setBounds((OrthoVS.fen.getContentPane().getWidth()/2-(i*100)), (OrthoVS.fen.getContentPane().getHeight()-(j*100))/2, i*100, j*100);
        }
        //this.setOpaque(false);
        setBackground(Color.CYAN);
        //Layout
        GridLayout g = new GridLayout(j, i) ;
        g.setHgap(6); g.setVgap(6);
        setLayout( g );
        setBorder(new EmptyBorder(10, 10, 10, 10) );
        
        //On crée les buttons
        grid = new MonkeyButton [i][j] ;
        
        for (int ii=0; ii<j; ii++)
            for (int n=0; n<i; n++)
                {
                grid[n][ii] = new MonkeyButton (n, ii) ;
                //original[n][ii].setFont(new Font("Arial", Font.PLAIN, 36));
                grid[n][ii].setBackground(Color.CYAN);
                //Insérer numéros
                /*if (!isMirror) grid[n][ii].setText("O"+n+ii);
                else grid[n][ii].setText("M"+n+ii);*/
                grid[n][ii].setBorder(new RoundedBorder(20));

                grid[n][ii].setVisible(true);
                if (isMirror)
                    grid[n][ii].addActionListener(this);
                add (grid[n][ii]) ;
                //Test border
                //Border thickBorder = new LineBorder(Color.GRAY, 2);
                //grid[n][ii].setBorder(thickBorder);
            }
        
        //On affiche
        setVisible (true) ;
    }
    
    public void randomInit () {
        //On réinitialise
        for (int i=0; i<grid.length; i++)
            for (int j=0; j<grid[0].length; j++) 
                grid[i][j].setBackground(Color.CYAN);
        if (isMirror) return ;
        //Nombre de cases à sélectionner
        int n = rand.nextInt(grid.length * (grid[0].length - 1)) + 2 ;
        int nn= 0 ;
        do {
            int i = rand.nextInt(grid.length) ;
            int j = rand.nextInt(grid[0].length) ;
            grid[i][j].setBackground(Color.ORANGE);
            nn ++ ;
        } while (nn < n) ;
        
    }
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (!vertical) {
            if (!isMirror)
                g.drawLine (this.getWidth()-1, 0, this.getWidth()-1, this.getHeight()) ;
            else
                g.drawLine (0, 0, 0, this.getHeight()) ;
        }
        else {
            if (isMirror)
                g.drawLine (0, 0, this.getWidth(), 0) ;
            else
                g.drawLine (0, this.getHeight()-1, this.getWidth(), this.getHeight()-1) ;
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        //Which one ?
        Object source = e.getSource () ;
        MonkeyButton j = (MonkeyButton) source ;
        //Change color
        if (j.getBackground() == Color.CYAN)
            j.setBackground(Color.ORANGE);
        else
            j.setBackground(Color.CYAN);
        validate () ;
        //Check if symetry is OK !
        if (LaunchSymetry.checkForSymetry ()) {
            LaunchSymetry.newGame = true ;
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent e) {
        int code = e.getKeyCode () ;
        if (code == VK_ESCAPE) {    //Sortir de la boucle de test, revenir à l'écran de paramétrage
            out = true ;
        }
        //if (code == VK_SPACE) randomInit() ;
    }

    @Override
    public void keyReleased(KeyEvent e) {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
    
}

class RoundedBorder implements Border {
        int radius;
        RoundedBorder(int radius) {
            this.radius = radius;
        }
        public Insets getBorderInsets(Component c) {
            return new Insets(this.radius+1, this.radius+1, this.radius+2, this.radius);
        }
        public boolean isBorderOpaque() {
            return true;
        }
        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
            g.drawRoundRect(x,y,width-1,height-1,radius,radius);
        }

    
    }